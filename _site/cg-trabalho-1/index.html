<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--><!--[if gt IE 8]><!--><html class="no-js">
<!--<![endif]--> <head> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> <title>Introdução à Computação Gráfica - Rasterização de Pontos e Linhas – Elcius Ferreira</title> <meta name="description" content="Website with academics and personal projects."> <meta name="keywords" content="computação gráfica, rasterização"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="/assets/img/logo.png"> <meta name="twitter:title" content="Introdução à Computação Gráfica - Rasterização de Pontos e Linhas"> <meta name="twitter:description" content=""> <meta name="twitter:site" content="@elciusferreira"> <meta name="twitter:creator" content="@elciusferreira"> <!-- Open Graph --> <meta property="og:locale" content=""> <meta property="og:type" content="article"> <meta property="og:title" content="Introdução à Computação Gráfica - Rasterização de Pontos e Linhas"> <meta property="og:description" content=""> <meta property="og:url" content="/cg-trabalho-1/"> <meta property="og:site_name" content="Elcius Ferreira"> <meta property="og:image" content="/assets/img/logo.png"> <link rel="canonical" href="/cg-trabalho-1/"> <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Elcius Ferreira Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="/assets/css/main.css"> <!-- JS --> <script src="/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="/favicon.png"> <link rel="shortcut icon" href="/favicon.ico"> <!-- Background Image --> <style type="text/css">body {background-image:url(/assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="/">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="/assets/img/logo.png" alt="Elcius Ferreira photo" class="author-photo"> <h4>Elcius Ferreira</h4> <p>Website with academics and personal projects.</p> </li> <li><a href="/about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="http://twitter.com/elciusferreira" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-twitter-square"></i> Twitter</a> </li> <li> <a href="http://facebook.com/elciusferreira" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-facebook-square"></i> Facebook</a> </li> <li> <a href="http://linkedin.com/in/elciusferreira" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-linkedin-square"></i> LinkedIn</a> </li> <li> <a href="http://instagram.com/elciusferreira_" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-instagram"></i> Instagram</a> </li> <li> <a href="http://github.com/elciusferreira" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> </ul>
<!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="/posts/">All Posts</a></li> <li><a href="/tags/">All Tags</a></li> </ul> </li> <li><a href="/projects/">Projects</a></li> </ul>
<!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn"> <div class="content"> <div class="post-title "> <h1>Introdução à Computação Gráfica - Rasterização de Pontos e Linhas</h1> <h4>04 Sep 2017</h4> <p class="reading-time"> <i class="fa fa-clock-o"></i> Reading time ~7 minutes </p>
<!-- /.entry-reading-time --> <a class="btn zoombtn" href="/posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <p><img src="/assets/img/cg-trabalho-1/initial_img.png" alt="Initial Image"></p> <p>Este post trata-se de um relatório sobre o primeiro trabalho da disciplina de Introdução à Computação Gráfica, ministrada pelo Prof. Dr. <a href="http://lattes.cnpq.br/4353928200012173">Christian Azambuja Pagot</a>.</p> <p>O trabalho consiste nas implementações de algoritmos para rasterização de primitivas na liguagem C/C++ em conjunto com as bibliotecas GLUT e OpenGL. Como os sistemas operacionais não permitem o acesso direto na memória de vídeo, será utilizado um framework, desenvolvido pelo professor, que tem como objetivo simular a memória de vídeo.</p> <h3 id="pixels">Pixels</h3> <p>Primeiramente algumas considerações: Em relação à disposição dos pixels no monitor, temos que considerar desde já que se trata de um espaço bidimensional (largura e altura) mas, a disposição dos pixels na memória se dá de forma linear, através do Color Buffer. Estes fatores devem ser respeitados para que o accionamento do pixel na posição correta seja feito.</p> <p>Foi utilizado neste trabalho o padrão RGBA, ou seja, cada pixel é formado por 4 componentes de cor: R para vermelho (RED), G para verde (GREEN), B para azul (BLUE) e A para o alfa (ALPHA). Considerando isto, temos o seguinte esquema:</p> <p><img src="/assets/img/cg-trabalho-1/color_buffer.png" alt="Color Buffer"></p> <p>Portanto, a posição de cada pixel e cada canal de um pixel na memória é dada da seguinte forma:</p> <p><img src="/assets/img/cg-trabalho-1/color_buffer2.png" alt="Color Buffer2"></p> <p>Consolidados estes conceitos, foi implementada a classe <strong>Pixel</strong> que possui todas as informações de coordenadas e cores relacionadas a ele.</p> <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Pixel</span>
<span class="p">{</span>

  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">red</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">green</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">blue</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">alpha</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

  <span class="n">Pixel</span><span class="p">(</span><span class="kt">int</span> <span class="n">X_coord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Y_coord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">R_comp</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">G_comp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">B_comp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">A_comp</span><span class="p">);</span>

  <span class="kt">int</span> <span class="nf">get_X</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="p">;}</span>
  <span class="kt">int</span> <span class="nf">get_Y</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">y</span><span class="p">;}</span>
  <span class="kt">double</span> <span class="nf">get_R</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">red</span><span class="p">;}</span>
  <span class="kt">double</span> <span class="nf">get_G</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">green</span><span class="p">;}</span>
  <span class="kt">double</span> <span class="nf">get_B</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">blue</span><span class="p">;}</span>
  <span class="kt">double</span> <span class="nf">get_A</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">alpha</span><span class="p">;}</span>

  <span class="kt">void</span> <span class="nf">set_X</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_x</span><span class="p">)</span> <span class="p">{</span><span class="n">x</span> <span class="o">=</span> <span class="n">new_x</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="nf">set_Y</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_y</span><span class="p">)</span> <span class="p">{</span><span class="n">y</span> <span class="o">=</span> <span class="n">new_y</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">set_RGBA</span><span class="p">(</span><span class="kt">double</span> <span class="n">new_r</span><span class="p">,</span> <span class="kt">double</span> <span class="n">new_g</span><span class="p">,</span> <span class="kt">double</span> <span class="n">new_b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">new_a</span><span class="p">);</span>

<span class="p">};</span>
</code></pre></div> <p>O framework disponibilizado pelo professor disponibiliza um ponteiro chamado FBPtr para o início da região do framebuffer e manipulando o mesmo foi possível implementar a função <strong>PutPixel()</strong> . Esta é responsável por rasterizar um ponto na memória de vídeo recebendo como parâmetro o objeto da classe Pixel, que possui a posição (x,y) dele na tela e sua cor (RGBA).</p> <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">PutPixel</span><span class="p">(</span><span class="n">Pixel</span> <span class="o">*</span><span class="n">pxl</span><span class="p">)</span>
<span class="p">{</span>

  <span class="k">if</span><span class="p">(</span><span class="n">pxl</span><span class="o">-&gt;</span><span class="n">get_X</span><span class="p">()</span><span class="o">&gt;</span><span class="n">IMAGE_WIDTH</span> <span class="o">||</span> <span class="n">pxl</span><span class="o">-&gt;</span><span class="n">get_X</span><span class="p">()</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">pxl</span><span class="o">-&gt;</span><span class="n">get_Y</span><span class="p">()</span><span class="o">&gt;</span><span class="n">IMAGE_HEIGHT</span> <span class="o">||</span> <span class="n">pxl</span><span class="o">-&gt;</span><span class="n">get_Y</span><span class="p">()</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// exceeded limits
</span>    <span class="k">return</span><span class="p">;</span>

  <span class="k">else</span>
  <span class="p">{</span>

    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pxl</span><span class="o">-&gt;</span><span class="n">get_X</span><span class="p">()</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="n">pxl</span><span class="o">-&gt;</span><span class="n">get_Y</span><span class="p">()</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="n">IMAGE_WIDTH</span><span class="p">;</span>  <span class="c1">// coordinates
</span>    <span class="n">FBptr</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pxl</span><span class="o">-&gt;</span><span class="n">get_R</span><span class="p">();</span>  <span class="c1">// red
</span>    <span class="n">FBptr</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pxl</span><span class="o">-&gt;</span><span class="n">get_G</span><span class="p">();</span>  <span class="c1">// green
</span>    <span class="n">FBptr</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pxl</span><span class="o">-&gt;</span><span class="n">get_B</span><span class="p">();</span>  <span class="c1">// blue
</span>    <span class="n">FBptr</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">pxl</span><span class="o">-&gt;</span><span class="n">get_A</span><span class="p">();</span>  <span class="c1">// alpha
</span>
  <span class="p">}</span>

<span class="p">}</span>
</code></pre></div> <p>Como resultado, temos:</p> <p><img src="/assets/img/cg-trabalho-1/pixel.png" alt="Pixel"></p> <h3 id="linhas">Linhas</h3> <p>Para a rasterização de linhas foi criada a função <strong>DrawLine()</strong> que recebe como parâmetros dois objetos da classe Pixel, o pixel inicial e final da linha.</p> <p>Vale ressaltar que durante todo o processo de rasterização da linha, apenas três objetos da classe <strong>Pixel</strong> são criados: O objeto referente ao pixel inicial, referente ao pixel final e um objeto referente ao pixel que a todo instante possui suas coordenadas x e y atualizadas. Este último irá ser sempre acendido na tela e como suas coordenadas mudam, eventualmente chegam até as do último pixel.</p> <p>Para realizar o processo de seleção dos pixels entre os pontos final e inicial da linha, foi utilizado o algoritmo de Bresenham. Este foi o maior desafio do trabalho devido a implementação e generalização do algoritmo para todos os 8 quadrantes do espaço 2D.</p> <p><img src="/assets/img/cg-trabalho-1/octantes.png" alt="Octantes"></p> <p>Os casos em que as linhas são verticais e horizontais tiveram que ser tratados separadamente. Para o caso da linha estar sobre o eixo Y (dx = 0), temos:</p> <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// line above axis y
</span>  <span class="p">{</span>

    <span class="k">if</span><span class="p">(</span><span class="n">inc_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// positive axis y
</span>    <span class="p">{</span>

      <span class="k">while</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">yf</span><span class="p">)</span>
      <span class="p">{</span>

        <span class="n">pix</span><span class="o">-&gt;</span><span class="n">set_Y</span><span class="p">(</span><span class="o">++</span><span class="n">y</span><span class="p">);</span>

        <span class="n">PutPixel</span><span class="p">(</span><span class="n">pix</span><span class="p">);</span>

      <span class="p">}</span>

    <span class="p">}</span>
    <span class="k">else</span>  <span class="c1">// negative axis y
</span>    <span class="p">{</span>

      <span class="k">while</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">yf</span><span class="p">)</span>
      <span class="p">{</span>

        <span class="n">pix</span><span class="o">-&gt;</span><span class="n">set_Y</span><span class="p">(</span><span class="o">--</span><span class="n">y</span><span class="p">);</span>

        <span class="n">PutPixel</span><span class="p">(</span><span class="n">pix</span><span class="p">);</span>

      <span class="p">}</span>

    <span class="p">}</span>

  <span class="p">}</span>
</code></pre></div> <p>Depois de tratar esses casos, o primeiro passo para a generalização foi identificar se os valores de x e y que compõem a reta crescem ou decrescem.</p> <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="n">xf</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">inc_x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">inc_x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// if true then x increases, else decreases
</span><span class="p">(</span><span class="n">yf</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">inc_y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">inc_y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// if true then y increases, else decreases
</span></code></pre></div> <p>Após identificar o valor das variáveis de controle <em>inc_x</em> e <em>inc_y</em> e sabendo se <em>dx &gt;= dy</em> ou <em>dx &lt; dy</em>, é possível acender os pixels que formarão a reta em qualquer quadrante considerando os valores da variável de decisão <em>d</em>. Por exemplo, para <em>dx &gt;= dy</em>, <em>inc_x = -1</em> e <em>inc_y = -1</em>, temos a seguinte implementação para o quinto quadrante:</p> <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">dx</span> <span class="o">&gt;=</span> <span class="n">dy</span><span class="p">)</span>
    <span class="p">{</span>

      <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">-</span> <span class="n">dx</span><span class="p">;</span>
      <span class="n">incr1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span><span class="p">;</span>
      <span class="n">incr2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">dy</span> <span class="o">-</span> <span class="n">dx</span><span class="p">);</span>

      <span class="k">while</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">xf</span><span class="p">)</span>
      <span class="p">{</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>

          <span class="n">d</span> <span class="o">+=</span> <span class="n">incr1</span><span class="p">;</span>
          <span class="n">x</span> <span class="o">+=</span> <span class="n">inc_x</span><span class="p">;</span>

        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>

          <span class="n">d</span> <span class="o">+=</span> <span class="n">incr2</span><span class="p">;</span>
          <span class="n">x</span> <span class="o">+=</span> <span class="n">inc_x</span><span class="p">;</span>
          <span class="n">y</span> <span class="o">+=</span> <span class="n">inc_y</span><span class="p">;</span>

        <span class="p">}</span>

        <span class="n">pix</span><span class="o">-&gt;</span><span class="n">set_X</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">pix</span><span class="o">-&gt;</span><span class="n">set_Y</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

        <span class="n">PutPixel</span><span class="p">(</span><span class="n">pix</span><span class="p">);</span>
      <span class="p">}</span>
</code></pre></div> <p>Como resultado, temos:</p> <p><img src="/assets/img/cg-trabalho-1/red_line.png" alt="Red Line"> <img src="/assets/img/cg-trabalho-1/red_lines.png" alt="Red Lines"></p> <h3 id="triângulos">Triângulos</h3> <p>Após a parte mais trabalhosa em termos de implementação, foi desenvolvida a função <strong>DrawTriangle()</strong>. Esta função desenha as arestas de um triângulo na tela recebendo como parâmetros os três pixels que representam os vértices. Lembrando que cada objeto pixel possui as informações de suas coordenadas x e y, além de suas componentes RGBA.</p> <p>Portanto, basta realizar a chamada da função <strong>DrawLine()</strong> três vezes passando dois vértices em cada.</p> <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DrawTriangle</span><span class="p">(</span><span class="n">Pixel</span> <span class="n">p1</span><span class="p">,</span> <span class="n">Pixel</span> <span class="n">p2</span><span class="p">,</span> <span class="n">Pixel</span> <span class="n">p3</span><span class="p">)</span>
<span class="p">{</span>

  <span class="n">DrawLine</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
  <span class="n">DrawLine</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">);</span>
  <span class="n">DrawLine</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span> <span class="n">p1</span><span class="p">);</span>

<span class="p">}</span>  
</code></pre></div> <p>Em tela, temos:</p> <p><img src="/assets/img/cg-trabalho-1/green_triangle.png" alt="Triângulo Verde"> <img src="/assets/img/cg-trabalho-1/green_triangles.png" alt="Triângulos Verdes"></p> <h3 id="interpolação-linear-de-cores">Interpolação Linear de Cores</h3> <p>A Interpolação Linear neste trabalho consiste em interpolar as cores desde o ponto inicial até o final da linha linearmente, logo uma transição gradual das cores ocorre dependendo da distância entre o início e o fim da reta.</p> <p>É realizada a diferença de cores entre os pontos final e inicial, obtendo assim uma variação de cor. Para tal finalidade foi implementada uma classe <strong>Distances</strong>. A mesma é responsável por armazenar e calcular informações relacionadas à distância entre os pontos e às distâncias referentes a cada cor e opacidade.</p> <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Distances</span>
<span class="p">{</span>

  <span class="kt">double</span> <span class="n">hypotenuse</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">r_distance</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">g_distance</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b_distance</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a_distance</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

  <span class="kt">int</span> <span class="n">get_Hypo</span><span class="p">(){</span><span class="k">return</span> <span class="n">hypotenuse</span><span class="p">;}</span>
  <span class="kt">int</span> <span class="n">get_RDist</span><span class="p">(){</span><span class="k">return</span> <span class="n">r_distance</span><span class="p">;}</span>
  <span class="kt">int</span> <span class="n">get_GDist</span><span class="p">(){</span><span class="k">return</span> <span class="n">g_distance</span><span class="p">;}</span>
  <span class="kt">int</span> <span class="n">get_BDist</span><span class="p">(){</span><span class="k">return</span> <span class="n">b_distance</span><span class="p">;}</span>
  <span class="kt">int</span> <span class="n">get_ADist</span><span class="p">(){</span><span class="k">return</span> <span class="n">a_distance</span><span class="p">;}</span>

  <span class="kt">void</span> <span class="n">setDistances</span><span class="p">(</span><span class="n">Pixel</span><span class="p">,</span> <span class="n">Pixel</span><span class="p">);</span>

<span class="p">};</span>
</code></pre></div> <p>Como visto, há um método chamado <strong>setDistances()</strong>. Este é responsável por receber os pixels inicial e final, calcular a hipotenusa que é distância entre os pontos em questão e calcular as distâncias entre os componentes RGBA.</p> <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Distances</span><span class="o">::</span><span class="n">setDistances</span><span class="p">(</span><span class="n">Pixel</span> <span class="n">start</span><span class="p">,</span> <span class="n">Pixel</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>

  <span class="kt">double</span> <span class="n">hypo</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">);</span> <span class="c1">// hypotenuse
</span>

  <span class="kt">int</span> <span class="n">r_dist</span> <span class="o">=</span> <span class="n">end</span><span class="p">.</span><span class="n">get_R</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">get_R</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">g_dist</span> <span class="o">=</span> <span class="n">end</span><span class="p">.</span><span class="n">get_G</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">get_G</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">b_dist</span> <span class="o">=</span> <span class="n">end</span><span class="p">.</span><span class="n">get_B</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">get_B</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">a_dist</span> <span class="o">=</span> <span class="n">end</span><span class="p">.</span><span class="n">get_A</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">get_A</span><span class="p">();</span>

  <span class="n">hypotenuse</span> <span class="o">=</span> <span class="n">hypo</span><span class="p">;</span>
  <span class="n">r_distance</span> <span class="o">=</span> <span class="n">r_dist</span><span class="p">;</span>
  <span class="n">g_distance</span> <span class="o">=</span> <span class="n">g_dist</span><span class="p">;</span>
  <span class="n">b_distance</span> <span class="o">=</span> <span class="n">b_dist</span><span class="p">;</span>
  <span class="n">a_distance</span> <span class="o">=</span> <span class="n">a_dist</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div> <p>Para cada linha que se deseja rasterizar, um objeto dessa classe é criado contendo todas essas informações.</p> <p>Posteriormente foi crianda a função <strong>Interpolate()</strong>, que recebe o pixel que irá ser acendido na tela e também recebe o objeto da classe <strong>Distances</strong> com todas as informações das distâncias.</p> <p>É feito um cálculo para se saber os novos valores das componentes RGBA baseando-se na distância que falta para se chegar nos valores de cor do pixel final. Cada pixel que irá ser acendido irá ter valores mais próximos a ele e assim a transição gradual de cor acontece.</p> <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Interpolate</span><span class="p">(</span><span class="n">Pixel</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">Distances</span> <span class="n">dist</span><span class="p">)</span>
<span class="p">{</span>

  <span class="kt">double</span> <span class="n">hypo</span> <span class="o">=</span> <span class="n">dist</span><span class="p">.</span><span class="n">get_Hypo</span><span class="p">();</span>
  <span class="kt">double</span> <span class="n">new_red</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">get_R</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">dist</span><span class="p">.</span><span class="n">get_RDist</span><span class="p">()</span><span class="o">/</span><span class="n">hypo</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">new_green</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">get_G</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">dist</span><span class="p">.</span><span class="n">get_GDist</span><span class="p">()</span><span class="o">/</span><span class="n">hypo</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">new_blue</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">get_B</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">dist</span><span class="p">.</span><span class="n">get_BDist</span><span class="p">()</span><span class="o">/</span><span class="n">hypo</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">new_alpha</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">get_A</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">dist</span><span class="p">.</span><span class="n">get_ADist</span><span class="p">()</span><span class="o">/</span><span class="n">hypo</span><span class="p">);</span>

  <span class="n">p</span><span class="o">-&gt;</span><span class="n">set_RGBA</span><span class="p">(</span><span class="n">new_red</span><span class="p">,</span> <span class="n">new_green</span><span class="p">,</span> <span class="n">new_blue</span><span class="p">,</span> <span class="n">new_alpha</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div> <p>Portanto, a função sempre vai ser chamada no momento anterior à chamada da função <strong>PutPixel()</strong></p> <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="p">...</span>
<span class="n">Interpolate</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">all_distances</span><span class="p">);</span>
<span class="n">PutPixel</span><span class="p">(</span><span class="n">pix</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div> <p>Como resultado, temos:</p> <p><img src="/assets/img/cg-trabalho-1/colored_lines.png" alt="Colored Lines"> <img src="/assets/img/cg-trabalho-1/colored_art.png" alt="Colored Art"> <img src="/assets/img/cg-trabalho-1/colored_triangle.png" alt="Colored Triangle"> <img src="/assets/img/cg-trabalho-1/colored_triangles.png" alt="Colored Triangles"> <img src="/assets/img/cg-trabalho-1/colored_triangles2.png" alt="Colored Triangles2"> <img src="/assets/img/cg-trabalho-1/colored_all2.png" alt="Colored All2"> <img src="/assets/img/cg-trabalho-1/colored_all.png" alt="Colored All"></p> <h3 id="considerações-finais">Considerações Finais</h3> <p>A maior dificuldade encontrada neste trabalho da disciplina foi a generalização do algoritmo de Bresenham para todos os octantes mas, após vários testes sua implementação correta foi alcançada.</p> <p>Uma segunda dificuldade encontrada estava na execução da interpolação. Por estar utilizando variáveis do tipo <em>int</em> para armazenar os valores das cores, a transição gradual não estava ocorrendo já que a quantidade de cor a ser adicionada poderia ser inferior a um, acontecendo assim o arredondamento para zero. Desta forma a cor não se alterava e permanecia a mesma para toda a reta. Este problema foi facilmente contornado ao utilizar variáveis do tipo <em>double</em>.</p> <p>Como melhoria seria interessante o preenchimento por completo dos triângulos inicialmente sem interpolação e posteriormente com.</p> <h3 id="bibliografia">Bibliografia</h3> <ul> <li><a href="https://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html">The Bresenham Line-Drawing Algorithm, por Colin Flanagan</a></li> <li><a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham’s line algorithm</a></li> <li><a href="http://www.flextool.com.br/tabela_cores.html">Tabela de cores</a></li> <li>Notas de aula do Prof. Christian</li> </ul> <h3 id="repositório-no-github">Repositório no Github</h3> <p>Acesse o repositório no Github <a href="https://github.com/elciusferreira/cg-rasterization">aqui</a>.</p> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="/tags/#computa%C3%A7%C3%A3o%20gr%C3%A1fica" title="Pages tagged computação gráfica" class="tag"><span class="term">computação gráfica</span></a><a href="/tags/#rasteriza%C3%A7%C3%A3o" title="Pages tagged rasterização" class="tag"><span class="term">rasterização</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=/cg-trabalho-1/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Share</span> </a> <a href="https://twitter.com/intent/tweet?text=/cg-trabalho-1/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=/cg-trabalho-1/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> </header> <!-- JS --> <script src="/assets/js/jquery-1.12.0.min.js"></script> <script src="/assets/js/jquery.dlmenu.min.js"></script> <script src="/assets/js/jquery.goup.min.js"></script> <script src="/assets/js/jquery.magnific-popup.min.js"></script> <script src="/assets/js/jquery.fitvid.min.js"></script> <script src="/assets/js/scripts.js"></script> <script type="text/javascript"> var disqus_shortname = 'taylantatli'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
